import datetime
from copy import deepcopy

import pytz
import requests
from dateutil.rrule import rrulestr
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils import timezone
from icalendar import Calendar

from elk.logging import logger


class ExternalEventManager(models.Manager):
    def by_src(self, src):
        return self.get_queryset() \
            .filter(src_id=src.pk) \
            .filter(src_type=ContentType.objects.get_for_model(src))


class ExternalEvent(models.Model):
    """
    Represents single External event.

    src is a contentype of the source, that has generated this event,
    for example :model:`extevents.GoogleCalendar`. src should be a subsclass
    of :model:`extevents.ExternalEventSource`.

    """
    objects = ExternalEventManager()

    teacher = models.ForeignKey('teachers.Teacher', on_delete=models.CASCADE, related_name='busy_periods')

    src_type = models.ForeignKey(ContentType, on_delete=models.CASCADE, limit_choices_to={'app_label': 'extevents'})
    src_id = models.PositiveIntegerField()
    src = GenericForeignKey('src_type', 'src_id')

    parent = models.ForeignKey('self', null=True, blank=True)

    start = models.DateTimeField()
    end = models.DateTimeField()
    description = models.TextField()
    last_update = models.DateTimeField(auto_now=True)


class ExternalEventSourceManager(models.Manager):
    def active(self):
        return self.get_queryset().filter(active=True).filter(teacher__active=True)


class ExternalEventSource(models.Model):
    """
    Generic abstract class for an external events source. External events source
    may be google calendar, icloud or anything you want. Subclasses should
    implement the following two methods:
        * `poll` method that popuates the self.events list
        * Relation to :model:`teachers.Teacher`, called 'teacher'

    Generic usage:
        # Assuming that teacher is an instance of :model:`teachers.Teacher`

        for calendar in teacher.google_calendars:
            calendar.poll()  # get new events, implemented in subclass
            calendar.update()  # update event database, implemented in this class

    This will clean up previous events and store new ones, fetched
    by the model:`extevents.GoogleCalendar`.poll() method.
    """

    objects = ExternalEventSourceManager()

    url = models.URLField()
    active = models.BooleanField(default=True)
    last_update = models.DateTimeField(auto_now=True)

    events = []

    def update(self):
        """
        Clean previous stored events generated by the source and store new ones.

        Notifies support when unsafe calendar update is performed, i.e. too much events got deleted.
        """
        if not self.__is_safe():  # warn admins if calendar update is unsafe
            logger.warning('Unsafe calendar update')

        self.__clear_previous_events()
        self.__save_events()

        if self.events:
            self.last_update = timezone.now()
            self.save()

    def __clear_previous_events(self):
        """
        Clear saved events where source is current instance.
        """
        self.__previous_events().delete()

    def __save_events(self):
        """
        Store polled events
        """
        for ev in self.events:
            ev.save()

    def __previous_events(self):
        """
        Get a list of events, generated by previous calendar pull
        """
        return ExternalEvent.objects.by_src(self).filter(teacher=self.teacher)

    def __is_safe(self):
        """
        Check if is it safe to update calendar event.

        For examples see extevents/tests/unit/tests_safety.py
        """
        if len(self.events) == 0 and self.__previous_events().count() > 1:
            return False

        if self.__previous_events().filter(parent__isnull=True).count() > 4:
            if self.__previous_events().filter(parent__isnull=True).count() / len(self.events) > 2:
                return False

        return True

    class Meta:
        abstract = True


class IcalEventSource(ExternalEventSource):
    EXTERNAL_EVENT_WEEK_COUNT = 8  # last all recurring events in 8 weeks to the future

    def poll(self):
        """
        Fetch a calendar, then parse it and populate the `event` property with
        events from it.
        """
        try:
            res = self.fetch_calendar(self.url)
        except:
            logger.warning('Could not fetch google calendar')
            self.events = []
        else:
            self.events = list(event for event in self.parse_events(res))

    def parse_events(self, ical_str):
        """
        Generator of events parsed from ical_str.
        """
        try:
            ical = Calendar.from_ical(ical_str)
        except:
            logger.warning('Could not parse ical string')
            raise StopIteration

        yield from self._simple_events(ical)  # first, parse all non-recurring events
        yield from self._recurring_events(ical)  # second — generate instances of ExternalEvent for every recurring event

    def _simple_events(self, ical):
        """
        Generate non-recurring events from icalendar. Ignore events in the past.
        """
        for ev in ical.walk('VEVENT'):
            if ev.get('rrule') is None:  # rrule is a repeating rule from icalendar RFC
                event = self.parse_event(ev)

                if event.start < timezone.now():
                    continue

                if (event.start - timezone.now()) > datetime.timedelta(weeks=self.EXTERNAL_EVENT_WEEK_COUNT):
                    continue

                yield event

    def _recurring_events(self, ical):
        """
        Generate recurring events from icalendar. Ignore events from the past except the first one.
        """
        for ev in ical.walk('VEVENT'):
            rrule = ev.get('rrule')  # rrule is a repeating rule from icalendar RFC
            if rrule is not None:
                basic_event = self.parse_event(ev)

                yield basic_event  # return basic event as the first event of the spree
                yield from self._recurring_event_generator(rrule, basic_event)

    def _recurring_event_generator(self, rrule, basic_event):
        """
        The main generator of recuring events.
        Input — generation rule (http://icalendar.readthedocs.io/en/latest/api.html#icalendar.prop.vRecur) and the source event(:model:`extevents.ExternalEvent`).
        Output — bunch of events, starting from the next future event, ending in timedelta(weeks=self.EXTERNAL_EVENT_WEEK_COUNT)
        """
        generating_rule = self._build_generating_rule(rrule)

        length = basic_event.end - basic_event.start  # basic length of event, apllited to all generated events

        for i in rrulestr(s=generating_rule, dtstart=basic_event.start):
            if i < timezone.now():
                continue

            if (i - timezone.now()) > datetime.timedelta(weeks=self.EXTERNAL_EVENT_WEEK_COUNT):
                return

            event = deepcopy(basic_event)
            event.start = i
            event.end = i + length

            event.parent = basic_event

            yield event

    def _build_generating_rule(self, rrule):
        """
        Return a string, parsable by dateutil.rrulestr, see https://dateutil.readthedocs.io/en/stable/rrule.html

        Turns recurring parameters (values of vRecur which is OrderedDict) to be
        timezone-aware.
        """
        def make_timezone_aware(date):
            if isinstance(date, datetime.date) and not isinstance(date, datetime.datetime):
                return datetime.datetime.combine(date, datetime.time.min.replace(tzinfo=pytz.timezone('UTC')))  # 00:00 in UTC timezone

            if isinstance(date, datetime.date) and not timezone.is_aware(date):
                return timezone.make_aware(date, 'UTC')

            return date

        for k in rrule.keys():
            rrule[k] = list(map(make_timezone_aware, rrule[k]))

        rule = "RRULE:" + rrule.to_ical().decode()
        return rule

    def parse_event(self, event):
        """
        Return an :model:`extevents.ExternalEvent` instance built from
        an icalendar event.
        """
        (start, end) = self._event_time(event)
        return ExternalEvent(
            start=start,
            end=end,
            description=event.get('summary'),
            teacher=self.teacher,
            src=self,
        )

    def _event_time(self, event):
        """
        Get a tuple with start and end time of event.

        All timestamps are returned in UTC.
        """
        start = event.get('dtstart').dt

        if event.get('dtend'):
            """
            When the end is not defined, let's hope it is a full-day event
            """
            end = event.get('dtend').dt
        else:
            end = start

        if isinstance(start, datetime.date) and not isinstance(start, datetime.datetime):
            """
            For single-day events we convert datetime.date objects returned
            by icalendar to datetime.datetime objects, adding '00:00' to the start time
            and '23:59' to the end time.
            """
            start = datetime.datetime.combine(start, datetime.time.min.replace(tzinfo=pytz.timezone('UTC')))  # 00:00 in UTC timezone
            end = datetime.datetime.combine(end, datetime.time.max.replace(tzinfo=pytz.timezone('UTC')))  # 23:59 in UTC timezone

        return (start, end)

    def fetch_calendar(self, url):
        r = requests.get(url, timeout=5)
        if r.status_code != 200:
            raise FileNotFoundError('Cannot fetch calendar url (%d)', r.status_code)
        return r.text

    class Meta:
        abstract = True


class GoogleCalendar(IcalEventSource):
    teacher = models.ForeignKey('teachers.Teacher', on_delete=models.CASCADE, related_name='google_calendars')
